/**
 * Cliente API centralizado com cache, retry e timeout configur√°veis
 * Melhora a confiabilidade das requisi√ß√µes e performance do app
 */

import { fetchWithRetry } from './fetchWithRetry';
import { GameDetailsCache } from './gameDetailsCache';

interface ApiClientOptions {
  /** Timeout em ms (padr√£o: 15000) */
  timeout?: number;
  /** N√∫mero de tentativas (padr√£o: 3) */
  retries?: number;
  /** Delay entre tentativas em ms (padr√£o: 1000) */
  retryDelay?: number;
  /** Usar cache (padr√£o: true) */
  useCache?: boolean;
  /** TTL do cache em ms (padr√£o: 30min) */
  cacheTTL?: number;
  /** Chave customizada para cache */
  cacheKey?: string;
  /** Headers adicionais */
  headers?: Record<string, string>;
  /** Callback para acompanhar tentativas */
  onRetry?: (attempt: number, error: Error) => void;
}

const DEFAULT_OPTIONS: Required<Omit<ApiClientOptions, 'cacheKey' | 'headers' | 'onRetry'>> = {
  timeout: 15000,
  retries: 3,
  retryDelay: 1000,
  useCache: true,
  cacheTTL: 30 * 60 * 1000, // 30 minutos
};

/**
 * Executa uma requisi√ß√£o GET com cache, retry e timeout
 */
export async function apiGet<T = any>(
  url: string,
  options: ApiClientOptions = {}
): Promise<T> {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  
  // 1. Verificar cache primeiro (se habilitado)
  if (opts.useCache) {
    const cacheKey = options.cacheKey || url;
    const cached = await GameDetailsCache.get<T>(cacheKey);
    
    if (cached) {
      console.log(`‚úÖ Cache hit: ${url}`);
      return cached;
    }
  }

  // 2. Fazer requisi√ß√£o com retry
  console.log(`üåê API Request: ${url}`);
  
  const response = await fetchWithRetry(url, {
    timeout: opts.timeout,
    retries: opts.retries,
    retryDelay: opts.retryDelay,
    onRetry: options.onRetry || ((attempt, error) => {
      console.log(`‚ö†Ô∏è Retry ${attempt}/3: ${error.message}`);
    }),
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const data: T = await response.json();

  // 3. Salvar no cache (se habilitado)
  if (opts.useCache) {
    const cacheKey = options.cacheKey || url;
    await GameDetailsCache.set(cacheKey, data, opts.cacheTTL);
    console.log(`üíæ Cached: ${url}`);
  }

  return data;
}

/**
 * Executa uma requisi√ß√£o POST (sem cache)
 */
export async function apiPost<T = any>(
  url: string,
  body: any,
  options: ApiClientOptions = {}
): Promise<T> {
  const opts = { ...DEFAULT_OPTIONS, ...options, useCache: false };

  console.log(`üåê API POST: ${url}`);

  const response = await fetchWithRetry(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
    body: JSON.stringify(body),
    timeout: opts.timeout,
    retries: opts.retries,
    retryDelay: opts.retryDelay,
    onRetry: options.onRetry || ((attempt, error) => {
      console.log(`‚ö†Ô∏è Retry ${attempt}/3: ${error.message}`);
    }),
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  return await response.json();
}

/**
 * Limpa o cache de uma URL espec√≠fica ou todo o cache
 */
export async function clearApiCache(url?: string): Promise<void> {
  if (url) {
    await GameDetailsCache.remove(url);
    console.log(`üóëÔ∏è Cache cleared: ${url}`);
  } else {
    await GameDetailsCache.clear();
    console.log('üóëÔ∏è All cache cleared');
  }
}

/**
 * Verifica conectividade com o servidor
 */
export async function checkApiConnection(baseUrl: string): Promise<boolean> {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);

    const response = await fetch(`${baseUrl}/health`, {
      signal: controller.signal,
      method: 'HEAD',
    });

    clearTimeout(timeoutId);
    return response.ok;
  } catch (error) {
    console.log('‚ùå API n√£o acess√≠vel');
    return false;
  }
}
